# Redis部署架构

*参考：[如何保证 Redis 高并发、高可用？ ](https://doocs.gitee.io/advanced-java/#/./docs/high-concurrency/how-to-ensure-high-concurrency-and-high-availability-of-redis)*

Redis单机能不能用？当然可以，架构的演进都是从单节点、小规模开始的。如果你的应用刚起步，用户不多，并发一般般，引入redis做做访问优化，单机完全够用。

等你做大做强了，就要渐渐考虑单机redis的问题，就一台机器挂了怎么办？这台机器的内存快满了怎么办？一台机器的并发渐渐扛不住了怎么办？

怎么办，加机器呗。并发抗不住？加一台机器做**一主一从**架构，读写分离，从节点只服务于读请求，还可以继续加机器做**一主多从**，支撑更高的读并发。容量不够用？水平扩容！**多主多从**，用jedis做客户端分片，再引入**哨兵**保证高可用（基于哨兵的高可用集群）。规模再扩大的话使用Redis的**集群模式**（服务端分片，集成了主从复制与哨兵）。

![image-20210829223252472](assets/image-20210829223252472.png)

## 1 主从架构

主从架构的意义是通过读写分离来降低单节点的压力。主从架构中的主承担写请求，从节点承担读请求，基于redis的主从复制机制将主节点的数据同步至从节点。

### 1.1 主从复制

[Replication – Redis](https://redis.io/topics/replication)

主从复制机制（master slave replication）是Redis主从架构的核心。 通过简单配置即可指定节点的主从角色及复制关系（*leader-follower*或称*master-slave*），从实例将是主实例的“精确副本”。当链接断开时，从实例都会自动重连主实例，而且无论主实例发生什么事，从实例都会将主实例的状态精确地复制过来（即使主实例宕机重启且没设置备份导致数据集空了，从实例也会将空数据集复制过来）。

简单描述一下这机制：

- 当主从实例构建了有效的连接，主实例会将其数据集的变更，源源不断以“流”的方式发送指令给从实例，这些指令包括：客户端的写指令、key的过期与淘汰等。
- 当主从断连（网络问题或是感知到超时），从节点会尝试重连主节点，如果连接成功，从节点会执行一个“部分重新同步”（partial resynchronization），只去同步断连期间丢失的这部分“指令流”。
- 如果“部分重新同步”搞不定了，从节点将会执行一次全量同步，这就需要获取主节点的RDB文件，通过RDB文件重构完从节点的数据集后，才继续通过“指令流”的方式来保持主从数据的同步（复制）。

现实中使用最多的一种模式，同时也是Redis默认的复制模式：异步复制，能够做到低延迟与高性能。

### 1.2 主从复制的一些重点

- Redis使用“异步复制”，从实例会向主实例发送已经处理的数据数量。
- 一个主实例可以拥有多个从实例。
- 从实例也可以拥有从实例（级联结构）。
  ![image-20210901095128919](assets/image-20210901095128919.png)
- 对于主实例来说，复制的过程是非阻塞的。无论从实例是在初始化同步（initial synchronization），还是在部分重同步（partial resynchronization），主实例都能不间断地处理请求。
- 复制过程中，从实例也**基本上**是非阻塞的。在初始化同步过程中，从实例会先用旧数据集提供查询（这个方式是配置的，否则的话查询请求返回error）。初始化同步结束后，从实例需要删除旧数据集并加载新数据集，在新数据加载完成前是**阻塞**的（大数据集的话可能需要many seconds）。
- 主从复制一般用于可伸缩架构（基于读负载扩容或缩容从节点），也可以用于高可用（如主节点挂了的话从节点还能继续提供读服务）。
- 主实例的自动持久化是可以配置为关闭的，在一些特殊的场景，需要避免主实例的写盘开销，可以将主实例配置为不持久化，同时将从实例开启自动持久化，以保证数据安全。不过这样的话**必须将主实例的自动重启关闭**，否则万一出现主实例宕机，主实例会以空数据集重启，复制会将从实例的数据也给清空。

### 1.3 主从复制的工作原理

主从复制有两个核心概念：

> - **Replication ID**: 一段伪随机的字符串，用于描述一个指定数据集
> - **Replication Offset**: 一个增长的数值，记录复制流的执行进度（偏移量）

这俩概念组合起来就能标识**特定数据集的精确版本**。

当从节点连接至主节点时，从节点会发送[PSYNC](https://redis.io/commands/psync)命令，将当前Replication ID和当前已处理的复制流的offset传给主节点，主节点从offset开始继续向从节点发送复制流（部分重同步partial resynchronization）。但是这种部分复制场景有例外：

1. 主节点中积压的复制流缓冲不能满足从offset开始复制（offset太老了）
2. 从节点请求的Replication ID与当前主节点的Replication ID不一致（主节点有俩ID，均与请求的ID不同时，这个俩ID在后面讲）

出现这俩场景时，主节点将会执行**全量复制**：

执行全量复制时，主节点开启后台进程保存RDB文件，同时开始缓冲客户端发来的写指令。RDB文件生成好后，传输给子节点，子节点利用该RDB文件重构数据集，然后主节点再将缓冲的“写指令流”发送给子节点。如果同时有多个从节点需要全量复制的话，主节点只会生成一个RDB文件，一对多进行全量复制。

## 2 基于哨兵的高可用

## 3 集群模式

