# Redis分布式锁

在分布式环境下，分布式锁是个相当有用的技术，常见的分布式锁的实现有基于数据库、zookeeper、Redis，这里主要讲Redis的分布式锁。本文是翻译整理于官方文档[Distributed locks with Redis](https://redis.io/topics/distlock)。

本文提出了Redis分布式锁的一种比较规范的算法，官方称之为Redlock。这个算法相对于一些单节点的方案来说更可靠一点。

## 1 安全性和可用性

该锁的设计者认为，一个合格的分布式锁，至少应当具备以下三个属性：

1. 安全性（Safety property）：**互斥**，同一时间只能有一个客户端持有锁。
2. 可用性一（Liveness property）：**无死锁**，所有锁最终都应当被释放，即使持有锁的客户端崩溃了或出现了网络隔离。
3. 可用性二：**容错**，只要（Redis）集群的大部分节点都在工作，分布式锁仍能正常占有或释放锁。

## 2 为什么基于故障转移的方案不太行

既然说现有的一些方案不太行，那我们就得扒一扒不行在哪里，并针对性地做出改进。

一般一个简单的基于Redis的分布式锁的方案是：使用一个单节点的redis，成功创建一个key，作为客户端持有锁的标志，一般这个key都会设置一个超时时间，以能保证锁的最终释放（可用性一）。当客户端需要释放锁时，删除key就行了。

这看起来没什么问题，而且大部分时间都没啥问题，但是问题是存在的：**单点故障**。单节点挂了咋办？加从节点啊，主节点挂了从节点上。但是这依旧不太行，因为我们需要保证分布式锁的互斥（安全性），而Redis的主从复制是异步的。在极端场景中，大概率会发生这种情况（race condition）：

1. 客户端A在主节点中占用了一个锁（key）。
2. 主节点宕机，但该key还没来得及复制到从节点。
3. 触发故障转移机制，从节点被提升为主节点。
4. 客户端B在新的主节点中拿到了相同的锁。**互斥失效了！**

![image-20210925001248615](assets/image-20210925001248615.png)

看具体业务场景吧，可能有的业务在故障发生时，允许多个客户端同时持有同一把锁，那么用这个基于故障转移的方案也没什么问题。但是我觉得大部分用到分布式场景中，出现这种状况时不能接受的。

## 3 单节点方案的正确操作

