# MySQL锁

锁嘛，对付并发用的。MySQL中的锁，根据锁定的范围，可以大致分为**全局锁**、**表级锁**与**行锁**。

## 1 锁定范围

### 1.1 全局锁

很显然的，全局锁就是给整个MySQL实例加锁，有个命令：

```shell
FLUSH TABLES WRITE READ LOCK
```

这个FTWRL命令会给整个MySQL加上只读锁，加锁后这些操作会被阻塞：

1. 数据更新语句（数据的增删改）
2. 数据定义语句（包括建表、修改表结构等）
3. 更新类事务的提交语句

这个锁是相当重量级的，看起来比较危险，毕竟阻塞了所有写操作。**它一般用于备份工具获取一致性备份。**不过对于InnoDB引擎来说，由于MVCC的支持，在可重复读的隔离级别下，无需阻塞写操作就能得到一致性的备份（`mysqldump`带上`--single-transaction`）。

### 1.2 表级锁

MySQL的表级锁分为：

- 表锁
- 元数据锁（MDL，Meta Data Lock）

#### 1.2.1 表锁

表锁就是[`LOCK TABLES t1 READ|WRITE`](https://dev.mysql.com/doc/refman/5.7/en/lock-tables.html)。

对t1加read锁的话：

- 当前session对t1只能read，不能write。
- 当前session对其他表不能read且不能write。
- 其他session对t1的write操作会阻塞。
- 其他session对其他表的操作无影响。
- 其他session可以同时对t1加read锁。

对t1加write锁的话：

- 当前session对t1可以read与write。
- 其他session对t1不能read，且不能write。
- 其他session同时对t1的加write锁操作会被阻塞，直至当前session释放write锁。

对表t1加表锁情况对比：

![image-20211122174122272](assets/image-20211122174122272.png)

`WRITE`锁的优先级要比`READ`锁要高，因为MySQL想要保证更新操作尽可能快地执行完。比如有一个session正在获取`READ`锁，然后另一个session在请求`WRITE`锁，那么后续的`READ`锁请求会阻塞，直至持有`WRITE`锁的session释放锁。

释放锁只需要执行：

```sql
UNLOCK TABLES;
```

session断开也会自动释放锁。

#### 1.2.2元数据锁

元数据锁MDL([Metadata Locking](https://dev.mysql.com/doc/refman/5.7/en/metadata-locking.html))主要作用是维护表元数据的数据一致性，**用于保证DDL操作与DML操作之间的一致性**。

MDL不需要显示地调用，每次执行DML语句时会申请MDL读锁，每次执行DDL语句时会申请MDL写锁。读锁之间不互斥，比如多个session可以同时对同一张表增删改查。但是读锁与写锁、写锁之间是互斥的。而且存在一个锁申请队列，队列中写锁的优先级是高于读锁的。

![image-20211123160901856](assets/image-20211123160901856.png)

MySQL 5.7新增了一张只读表`performance_schema.metadata_locks`，专门用来记录MDL的相关信息。不过5.7中是默认关闭的，需要这么开启：

```sql
UPDATE performance_schema.setup_instruments
SET ENABLED = 'YES', TIMED = 'YES'
WHERE NAME = 'wait/lock/metadata/sql/mdl';
```

*参考《[深入理解MDL元数据锁](https://cloud.tencent.com/developer/article/1553461)》与《[MySQL元数据锁(MDL)](http://mytecdb.com/blogDetail.php?id=183)》*

### 1.3 行锁

