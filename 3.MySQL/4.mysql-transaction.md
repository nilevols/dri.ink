# MySQL事务

数据库事务是个老生常谈的东西。一个事务指的是一组对数据库的操作集合（序列），这组操作要么全部执行，要么全部不执行。一个事务可以看成是一个独立的、不可分割的单位。

## 1 事务的ACID

ACID是保证数据库事务正确可靠的四个特性：

- 原子性（Atomic）：一个事务中的所有操作，要么全部完成，要么全部不完成。事务中任意步骤出错，整个事务会回滚到事务初始的状态（好像事务没执行过一样）。
- 一致性（Consistency）：事务前后数据的状态是一致的，事务对数据的变更，会保证数据的完整性，符合预设的规则。比如转账前后，两个账户的金额总和是不变的。
- 隔离性（Isolation）：事务的执行是独立的，一个事务的执行不会影响另一个事务的执行。
- 持久性（Durability）：完成的事务（提交成功的），其对数据的变更是永久的。即使紧跟着系统崩溃，也不会导致数据（变更）的丢失。

## 2 隔离性与事务中的问题

我们把ACID中的'I'（隔离性）展开讲讲。要知道“隔离”实际上并不是绝对的，“隔离”的概念发生在多个事务同时执行时，绝对的“隔离”会导致低效率（需要使本应并行的事务串行执行，绝对不会互相干扰，就像Java并发中的同步锁，安全，但性能肯定跟不上）。

显然这样是没有必要的，但是允许并行执行事务，可能会导致一些问题：

### 2.1 脏读（Dirty Read）

**脏读是一个事务读取到了另一个事务未提交的内容。**图示：

![image-20211019195606136](assets/image-20211019195606136.png)

图示中事务A读取到了事务B未提交的值更新（2），然后依据此值做了计算，并提交到数据库中，结果事务B却回滚了。从此破坏了数据的一致性。

### 2.2 不可重复读（Unrepeatable Read）

**不可重复读是在同一个事务中，前后两次读取到的内容不一致。**图示：

![image-20211019202247434](assets/image-20211019202247434.png)

图示中事务A对c值的第二次读取，与第一次读到的值不同，原因是事务B在事务A执行期间更新了c值并提交成功。

### 2.3 幻读（Phantom Read）

**幻读是一个事务根据条件查询到的数据集，在第二次以相同条件查询到了不同的数据集。**图示：

![image-20211019204003953](assets/image-20211019204003953.png)

事务A以条件`id >= 1`查询，匹配到了2行数据，事务B跟着插入了新的一行数据并提交了，事务A再次以条件`id >= 1`查询，却匹配到了3行数据。（看着与不可重复读类似？有本质区别，下面会讲到应对不可重复读的隔离级别，通过对已读到的数据记录加锁，锁不住新增的记录行。）

## 3 隔离级别

*（本节部分整理于：《[Transaction Isolation Levels](https://dev.mysql.com/doc/refman/5.7/en/innodb-transaction-isolation-levels.html)》）*

对于上述提及的几个问题，本质上是不同“隔离”程度中会发生的现象，SQL标准定义了四个隔离级别：

- 读未提交（Read Uncommitted ）
- 读已提交（Read Committed）
- 可重复读（Repeatable Read）
- 可串行化（Serializable ）

### 3.1 读未提交（Read Uncommitted ）

读未提交是最低级别的隔离，在此级别下，一个事务能够读到其他事务未提交的改动，这就导致了“脏读”现象。

### 3.2 读已提交（Read Committed）

读已提交保证了事务中能够读取到的值必须是其他事务已经提交的内容，这杜绝了“脏读”现象。这个级别下，当前事务持有了当前行的读写锁，阻止了其他事务对改行数据的读写操作。

对于*一致性读（consistent read）*，即使是同一个事务中的多次读，取的都是同一个快照中的内容。（快照是MVCC中的东西，下面讲）

> 一致性读（consistent read），读操作是基于某个时间点的数据库快照，不用担心在同一时间其他并行的事务对相同的数据做变更操作。
>
> 参见：[consistent read](https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_consistent_read)

对于加锁读（`SELECT FOR UPDATE`或`LOCK IN SHARE MODE`）、`UPDATE`语句、`DELETE`语句，只会对指定索引行加锁，而不是用*间隙锁（gap lock）*，所以在锁定行之间是允许插入新行的（这就导致了幻读）。

> 间隙锁（gap lock），其一种加在索引记录之间的间隙上，或是加在第一行索引记录之前，或是最后一行索引记录之后的一种锁。
>
> 参见：[gap lock](https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_gap_lock)

### 3.3 可重复读（Repeatable Read）

这个级别是**MySQL的默认隔离级别**。可重复读保证了事务从开始到结束，期间任何时候读到的数据行的内容都是一致的。

对于一致性读（consistent read），其读的是同一个事务中，第一个读操作建立的快照。同一个事务中的多个不加锁的`SELECT`语句，是互不影响的，且结果是一致的。

对于加锁读（`SELECT FOR UPDATE`或`LOCK IN SHARE MODE`）、`UPDATE`语句、`DELETE`语句，取决于语句使用的是唯一索引的唯一搜索条件，还是范围类型搜索条件。

- 对于唯一索引的唯一搜索条件，会给命中的索引记录加锁，而非给其之前的间隙加锁（间隙锁中的“加在命中的第一行索引记录之前”）。
- 对于其他的搜索条件，会给索引范围加锁。其使用的是间隙锁（gap lock）或是 *下一键锁（next-key lock）*，这种锁会阻塞其他事务将新行插入到被锁定范围的索引上。

> next-key lock，是指定索引记录的行锁与索引记录前的间隙锁的结合。
>
> 参见：[next-key lock](https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_next_key_lock)

对于Read Committed和Repeatable Read两个隔离级别的行加锁情况，我们用例子来辅助理解，假设有这张表与表中的5行数据：

```sql
CREATE TABLE t (a INT NOT NULL, b INT) ENGINE = InnoDB;
INSERT INTO t VALUES (1,2),(2,3),(3,2),(4,3),(5,2);
COMMIT;
```

先启动Session A，对`b=3`的行执行更新：

```mysql
# Session A
START TRANSACTION;
UPDATE t SET b = 5 WHERE b = 3;
```

再启动Session B，对`b=2`的行执行更新：

```mysql
# Session B
UPDATE t SET b = 4 WHERE b = 2;
```

作为InnoDB引擎，如果想要执行`UPDATE`语句的话，会先将读到的行加上一个排他锁（下面示例中是x-lock），然后再判断是否要修改这一行。如果不需要修改，那么会释放该行锁，如果修改了，那么这行锁会持续持有到事务结束。

对于Repeatable Read级别，Session A中的`UDPATE`会将所有行加锁，并持有到事务结束：

```
x-lock(1,2); 持有x-lock
x-lock(2,3); update(2,3) to (2,5); 持有x-lock
x-lock(3,2); 持有x-lock
x-lock(4,3); update(4,3) to (4,5); 持有x-lock
x-lock(5,2); 持有x-lock
```

在Session B中的`UPDATE`，会阻塞，直至Session A的事务提交或回滚：

```
x-lock(1,2); 阻塞等待
```

对于Read Committed级别来说，不需要修改的行会立刻释放锁，只有需要修改的行才会阻塞到事务结束， Session A：

```
x-lock(1,2); unlock(1,2)
x-lock(2,3); update(2,3) to (2,5); 持有锁x-lock
x-lock(3,2); unlock(3,2)
x-lock(4,3); update(4,3) to (4,5); 持有锁x-lock
x-lock(5,2); unlock(5,2)
```

Session B：

```
x-lock(1,2); update(1,2) to (1,4); 持有锁x-lock
x-lock(2,3); unlock(2,3)
x-lock(3,2); update(3,2) to (3,4); 持有锁x-lock
x-lock(4,3); unlock(4,3)
x-lock(5,2); update(5,2) to (5,4); 持有锁x-lock
```

### 3.4 可串行化（Serializable）

这是隔离的最高级别，在这个级别下，会互相干扰的两个事务（比如分别读写同一张表）会串行执行。

这个级别有点类似可重复读，但是如果在 [`autocommit`](https://dev.mysql.com/doc/refman/5.7/en/server-system-variables.html#sysvar_autocommit)被禁用的情况下，InnoDB会将所有普通`SELECT`语句隐式地转换为 `SELECT ... LOCK IN SHARE MODE`（这会使这条`SELECT`阻塞，直至其他事务提交，Repeatable Read级别下，普通`SELECT`读的是快照，不会阻塞。）。如果`autocommit`被启用，普通的`SELECT`语句（一致性读）读取的是自己的快照，不会为其他事务所阻塞。（如果实际场景中的确需要普通读也被阻塞的话，需要把`autocommit`关掉。）

## 4 多版本并发控制（MVCC）

多版本并发控制（Multi-Version Concurrency Control）

