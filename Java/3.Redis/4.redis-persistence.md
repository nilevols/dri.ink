# Redis持久化

*参考：[Redis 的持久化有哪几种方式？](https://doocs.gitee.io/advanced-java/#/./docs/high-concurrency/redis-persistence)*

*参考：[Redis Persistence](https://redis.io/topics/persistence)*

Redis的是个内存数据库，它的高效率操作都是基于内存的。这样的话，如果服务器宕机重启，数据不就丢了吗？Redis基于此提供了 持久化机制，在内存操作的同时，将内存中的数据**异步**写入磁盘。在Redis重启时，将数据从持久化文件里恢复到内存中。

Redis提供了几种持久化方案的选项：

- **RDB**(Redis Database)：以指定的时间间隔，周期性地保存内存“快照”。
- **AOF**(Append Only File)：以日志的方式记录每一条写操作。需要恢复时，将这些写操作依次跑一编来重构内存数据集。
- **RDB + AOF**：Redis支持在一个实例中同时使用RDB与AOF。但是需要注意的是，在恢复时，会选择AOF文件，因为AOF方式保存的数据相对更完整。
- 无持久化：你也可以选择关闭持久化。

RDB与AOF两种持久化方案各有千秋，使用时需要根据二者的优劣势结合实际需求选择使用。

## 1 RDB

### 1.1 优势

- 作为内存快照来说，对比AOF方式记录的文件，RDB文件通常比较“袖珍”，所以它非常适合用来做备份。比如你可以保留24小时的每小时快照，或是保留一个月的每日快照，真要遇到某些“操蛋”的场景，你可以选择不同版本的快照来快速恢复数据集。
- 对Redis性能影响较小，主进程不需要进行磁盘IO，是需要fork出一个子进程来进行磁盘IO操作。
- 对于大数据集来说，RDB的恢复速度要比AOF要快。
- 在主从复制机制中，RDB保证了重启和故障转移时的*部分复制*

### 1.2 劣势

- 数据不完整。真要碰上需要恢复数据的时候，RDB会丢失上次快照时到宕机时的数据。
- 数据集非常大时，会影响性能。RDB是靠fork出的子进程来工作的，如果数据集很大而且CPU性能不咋地，可能会导致Redis暂停服务几毫秒甚至一秒。

## 2 AOF

### 2.1 优势

- 数据更完整。默认策略是每秒`fsync`一次，`fsync`是后台线程跑的，最多只会丢失1秒数据。
- AOF日志是`append-only`的，文件不易破损，即使出现如断电等情况导致的文件尾不完整，也可以通过*redis-check-aof*工具轻松修复。
- AOF重写机制。AOF是逐一记录写操作的日志，所以AOF文件一直在增大，过大时触发重写机制。重写是在后台线程中进行的，在保证恢复后的数据不变的情况下尽可能地压缩日志。在重写时，`fsync`仍往旧文件中append，同时重写操作往新文件中写，新文件就绪后，Redis切换到新文件，并往新文件中append。
- AOF文件是可读的。这玩意就是一日志文件，里面记录了一条接着一条的写操作，你甚至可以把AOF文件导出来，修改修改放回去（比如有人执行了`FLUSHALL`然后跑路了，你可以停掉Redis后，把AOF文件的最后几条命令删掉，然后启动Redis）。

### 2.2 劣势

- 对于相同数据集来说，AOF文件比RDB文件更大。
- 相对来讲会比RDB慢一点，但即使是配置的`fsync`一秒一次，也能表现出很高的性能。如果关掉fsync的话（配置为`appendfsync no`），那性能上基本与RDB没差了。
- **概念上讲**，RDB方式更健壮一点。Redis官方曾经遇到过一个BUG，通过AOF恢复的数据集，与原数据集不一致。AOF机制是一种基于已有状态做的增量变更，而RDB是每次都是从0构建。但是AOF的重写机制，每次重写都是基于内存数据集从0构建的，而非基于老的AOF文件。

