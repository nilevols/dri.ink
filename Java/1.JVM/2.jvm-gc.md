# JVM垃圾回收机制

## 概述

了解完jvm内存区域的知识，必然会引申到jvm的垃圾回收机制。**垃圾回收(Garbage Collection, GC)**，简单来讲就是清理掉jvm内存中的垃圾对象，以释放空间，更有效地利用内存。

## 如何判断垃圾

### 引用计数法

 Java中，使用一个对象必须通过引用来进行。那么是不是可以这样认为：*当一个对象没有有效的引用指向它时，这个对象差不多可以被干掉了。*那么我们给每一个对象加一个`引用计数器`，每有一处引用指向它时，计数器+1，当引用失效时，计数器-1。需要的时候，检查对象的计数器，当计数器归0时，认定当前对象为可回收。

但是，引用计数法无法解决对象的**循环引用**问题。

![image-20210627130252475](assets/image-20210627130252475.png)

### 可达性分析

为了解决上面的问题，Java采用了***可达性分析***算法。其思想是，通过一系列`GC Roots`对象作为起点进行搜索，如果在`GC Roots`对象和一个对象之间没有可达路径，则认为该对象是不可达的。但是不可达对象并不等价于可回收对象，判定为不可达对象要变为可回收对象，至少需要经过两次标记过程。两次标记后仍是不可达对象的，将面临回收。

![image-20210627130330958](assets/image-20210627130330958.png)

可作为GC Roots的对象包括但不限于如下几种：

1. 虚拟机栈(栈帧中的本地变量表)中引用的对象
2. 方法区中静态属性引用的对象
3. 方法区中常量引用的对象
4. 本地方法栈中引用的对象

## 垃圾回收算法

### 标记清除法

标记清除法是将垃圾清除分为两个阶段：

1. 标记：从根节点开始标记出需要回收的对象
2. 清除：清理需要回收的对象，回收空间

![image-20210627132405023](assets/image-20210627132405023.png)

标记的过程采用`可达性分析算法`，这样虽然能解决循环引用问题，但是标记清除算法有明显的缺点：

- 效率低，需要两次遍历
- 清理出的空间碎片化严重

### 标记整理（压缩）法

针对标记清除法空间碎片化的缺点，有人提出了标记整理法（Mark-Compact），其标记阶段与标记清除法相同，但在标记完对象后，将所有存活的对象向内存空间的一端移动，然后直接清理掉端边界外的对象。

![image-20210627133746906](assets/image-20210627133746906.png)

这样就解决了空间碎片化的特点，但是效率略低。

### 复制算法

复制算法是将内存空间划分为大小相同的两块，每次只使用其中一块内存，在垃圾回收时，将存活对象复制到另一块内存空间中，然后将当前内存空间清空，并交换两块内存角色。

![image-20210627135824869](assets/image-20210627135824869.png)

很明显的，其最大的缺点就是**浪费空间**，但是它快啊，在存活对象少的情况下，复制操作少，效率高。但如果存活对象多的话，就不太合适了。

### 分代收集法

分代收集法是目前最常见的JVM垃圾回收策略，其思想是根据对象的不同生命周期将内存划分为不同的区域。一般划分为**新生代（Young Generation）**和**老年代（Tenured/Old Generation）**。新生代的特点是每次GC都会有大量对象被回收，而老年代每次GC时只有少量对象被回收。结合上述几种垃圾回收算法的各自优缺点，不同区域可以选择不同的垃圾回收算法。

新生代适合复制算法，老年代适合标记清除法或标记整理法

## 垃圾收集器

JVM目前提供了多种垃圾收集器，大部分都是分代专用的。

新生代：

- Serial
- ParNew
- Parallel Scavenge

老年代：

- CMS
- Serial Old
- Parallel Old

通用：

- G1

### Serial垃圾收集器

Serial是最基础的垃圾收集器，它是单线程的，使用的是复制算法。在垃圾收集时，程序会暂停手上所有的工作线程（STW，Stop The World），直到垃圾收集结束。不过又由于单线程没有了上下文的切换，而且对于新生代来说，一般需要复制的对象比较少（存活对象较少），所以整体上Serial算是高效的，是比较适合新生代的垃圾收集器。

![image-20210627215808998](assets/image-20210627215808998.png)

### ParNew收集器

ParNew是Serial的多线程版本，除了在垃圾收集时采用多线程，其余行为均与Serial完全相同。Par是指Parallel，并行的意思，这里的多线程并不是说垃圾采集与工作线程并发，在垃圾收集时同样需要STW。

ParNew收集器会默认开启与CPU数量相同的线程数，也可以通过参数`-XX:ParallelGCThreads`来指定线程数。所以在多CPU的情况下，ParNew会比Serial效果要好，但在单CPU时，由于需要上下文切换，ParNew反而不如Serial。

![image-20210627215947451](assets/image-20210627215947451.png)

相关参数：

- `-XX:ParallelGCThreads`：指定GC线程的数量，默认与cpu数量相同
- `-XX:UseConcMarkSweepGC`：强制使用CMS时，会默认使用ParNew
- `-XX:UseParNewGC`：在新生代指定使用ParNew

### Parallel Scavenge收集器

通常也被称作吞吐量收集器（Throughput Collector）。与ParNew类似，Parallel Scavenge也是使用的**复制算法**，同时GC时也是**多线程**的。与其他收集器不同的是，其是**面向吞吐量要求的（吞吐量优先）**。

> 吞吐量 = 用户代码运行时间 / (用户代码运行时间 + 垃圾回收时间)

高吞吐量就是高效地利用CPU时间，尽快地完成程序的计算任务。这适用于更关注计算任务结果，而不是存在较多交互的程序，比如批量处理、定时任务执行、复杂运算等。

相关参数：

- `-XX:MaxGCPauseMillis`：最大垃圾收集停顿时间，大于零的毫秒数
- `-XX:GCTimeRatio`：垃圾收集时间占比。指定一个1-99的整数n，则垃圾收集时间与程序工作时间的占比被设置为1:n。例*-XX:GCTimeRatio=19*，那么垃圾收集时间占整个CPU时间的1/(1+19)，即会有5%的时间会用在垃圾收集上。（这个值默认设置是99）

### Serial Old收集器

Serial Old是Serial收集器的老年代版本，是**单线程的**，使用**标记整理算法**。Serial与SerialOld的搭配如图：

![image-20210628215938143](assets/image-20210628215938143.png)

### Parallel Old收集器

Parallel Old收集器是Parallel Scavenge收集器的老年代版本。使用的是**标记整理算法**，同时也是**多线程**的。与Parallel Scavenge的搭配如图：

![image-20210628220506149](assets/image-20210628220506149.png)

### CMS收集器

CMS（Concurrent Mark Sweep）收集器，以获取最短回收停顿时间（STW时间）为目标。基于**标记清除法**的老年代**并发**收集器。这里的“并发”指的是在其垃圾收集过程中，某些阶段GC线程和工作线程是可以并发执行的。

CMS收集器对比上面的几个收集器，它的垃圾采集过程相对更复杂一点，共有七个步骤：

1. 初始标记 - 只是标记一下与GC Roots直接关联的对象，有STW
2. 并发标记 - 进行GC Roots的可达性追踪，与工作线程并发执行，无STW
3. 重新标记 - 修正并发标记期间有变更的对象标记记录，有STW
4. 并发清除 - 清除标记出来的不可达对象，与工作线程并发执行，无STW

由于最耗时的并发标记和并发清除是与工作线程并发执行的，总体上看，CMS的停顿时间较少，交互上更友好。

![image-20210629213718978](assets/image-20210629213718978.png)

关于`concurrent mode failure`，在CMS并发清理阶段，由于对象还在源源不断往老年代中生成或复制，那么便有可能出现：1. 老年代空间耗尽前，未能完成对垃圾对象的回收；2. 新的空间分配请求未能在老年代剩余空间中得到满足。便会导致concurrent mode failure，此时JVM将会以停顿的方式执行full GC（Serial Old），显然这样不太美好。

关于CMS的触发时机，[这篇博客](https://blog.csdn.net/Ryanqy/article/details/104946950)讲解地非常详细，作者扒了JVM的源码来分析了CMS的触发条件。常见的几种触发条件有：1. 基于历史CMS的运行指标统计，预测下一次CMS完成所需时间大于老年代预计填满的时间（如果是第一次CMS，没有统计数据怎么办？答案是根据老年代使用占比来判断，达到50%）；2. 老年代的空间使用占比达到阈值（92%，这个值文章中是通过源码中的公式计算出来的）。 

### 分代收集器的搭配使用

![image-20210630223852850](assets/image-20210630223852850.png)

`-XX:UseSerialGC`

### G1(Garbage First)垃圾收集器

G1的存在是为了取代CMS。



