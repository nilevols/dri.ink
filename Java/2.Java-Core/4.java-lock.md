# Java锁

## 1 乐观锁与悲观锁

乐观锁与悲观锁只是广义上的锁的概念，并非具体的锁的实现。二者概念上的区别在于对待操作同步资源时对于竞争的态度。

悲观锁认为当前线程在修改某个数据时，一定会有别的线程也来修改这个数据，所以会给修改的过程枷锁，保证别的线程无法同时修改该数据。

![image-20210728233841772](assets/image-20210728233841772.png)

而乐观锁认为当前线程在修改数据时，不太可能有别的线程过来同时修改，所以我不打算加锁，我只是在更新该数据前，判断数据是否发生了变化，若没有变，说明当前只有我在操作，就把数据更新掉，否则的话说明数据被别的线程修改了，再决定报错或是重来一遍。（下图虚线框中的操作需要保证原子）

![image-20210728233852182](assets/image-20210728233852182.png)

悲观锁在Java中的应用有`sychronized`和`ReentrantLock`，乐观锁的应用有`AtomicInteger`等原子类（`java.util.concurrent.atomic`包）。`AtomicInteger`主要是使用了**CAS**技术来实现原子新增的。

CAS全称 Compare And Swap（比较与交换），是一种无锁算法。旨在不加锁的情况下（无阻塞）来实现多线程间的变量同步。CAS算法涉及三个变量：

- 需要进行读写的变量V
- 进行比较的值A
- 打算写入的值B

*当且仅当V的值等于A时，才允许用B来更新V的值。*这个比较+更新是一个**原子操作**，一般借助CPU指令完成。若比较时不相等，一般会采取重试操作。

 `AtomicInteger`的自增函数`incrementAndGet()`中，使用的是`unsafe.getAndAddInt()`（`Unsafe`类是类似于C语言一样操作内存空间，其只是在JDK的某些地方用的，官方并不推荐开发者直接使用）。

```java
// ----------AtomicInteger----------
public final int incrementAndGet() {
    return unsafe.getAndAddInt(this, valueOffset, 1) + 1;
}

// ----------Unsafe.class(反编译)----------
public final int getAndAddInt(Object var1, long var2, int var4) {
    int var5;
    do {
        var5 = this.getIntVolatile(var1, var2);
    } while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4));

    return var5;
}
```

其先获取想要操作的内存地址上的值，`compareAndSwapInt()`借助底层的原子操作，比较内存地址上的值与预期的值是否相等，若相等则将该内存地址上的值替换为该值加1，并返回原来的值。若不相等，则重新获取该内存地址上的值，再`compareAndSwapInt`()，如此循环，直至替换成功。

CAS虽然对比锁机制更高效，但仍然存在一些问题：

- **ABA问题**。CAS在比较时，会拿修改前的值与当前值对比，比如修改前的值是A，现在也是A，就可以更新成功。但若在这期间有另一个线程将其更新为了B，又将其更新为了A，这样也能更新成功，这就有问题了。解决办法是给值加上版本号，每次更新把版本号加一。
- **循环开销问题**。若CAS一直不能更新成功，它就会一直在那自旋，浪费CPU资源。解决办法是给自旋次数设置上限，自旋次数达到上限后，挂起线程。

## 2 自旋锁与适应性自旋锁

线程的上下文切换是消耗CPU资源的，如果持有锁的线程能够在短时间内释放资源，那么竞争该资源的其他线程在获取锁失败后，不进入阻塞挂起状态，它们只需要等一等（自旋），等资源释放后立刻获取锁。这样用自旋的小消耗来换上下文切换的大消耗。

但是自旋锁本身并不能代替阻塞，自旋锁只是用自旋的消耗来替代上下文切换的消耗，若自旋的消耗更大的话（持有锁的线程长时间占有锁导致较长的自旋时间），就非常不划算了。

所以自旋必须有个限度，给自旋锁限定一个次数上限，若自旋次数达到上限后仍未获得锁，就挂起线程。

> -XX:PreBlockSpin=10 // 设置自旋次数上限10次

JDK1.6引入了适应性自旋锁，其自旋的次数不在固定，**由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定**。对于同一个锁对象，如果短时间内有成功通过自旋获取到锁，且目前持有者正在运行，那么就认为下一次自旋很可能成功，允许其自旋更多次数。但若这个锁对象很少有通过自旋获取到锁，便可以认为下一次自旋不太可能成功，就直接放弃自旋，进入阻塞状态。

## 3 无锁、偏向锁、轻量级锁、重量级锁

这四种锁指的是锁的几种状态。

我们先从“对象头”讲起，什么是“对象头”？通过前面的讲的，我们现在知道了synchronized锁是悲观锁，我们在操作同步资源之前，会先将同步资源加锁，这个锁就是加在同步资源的对象头上。对象头主要包括两部分数据：**Mark Word（标记字段）**、**Klass Pointer（类型指针）**。

- **Mark Word（标记字段）**：无锁时默认存储的是对象的hashCode、分代年龄及锁标志位信息。这里存储的内容会随着锁状态的变化而变化。
- **Klass Pointer（类型指针）**：存储着指向方法区中对象对应类信息的指针。

|  锁状态  |                                          Mark Word (64 bits) |
| :------: | -----------------------------------------------------------: |
|   无锁   | 对象hashCode、分代年龄、是否是偏向锁biased_lock(0)\|锁标志位lock(01) |
|  偏向锁  | 偏向线程ID、偏向时间戳、对象分代年龄、是否是偏向锁biased_lock(1)\|锁标志位lock(01) |
| 轻量级锁 |                   指向（栈中）锁记录的指针\|锁标志位lock(00) |
| 重量级锁 |          指向重量级锁（monitor对象）的指针\|锁标志位lock(10) |

synchronized底层是通过monitor（监视器锁）来实现的。在JVM中，每一个对象都会对应一个monitor，在javap反编译的字节码中我们能看到同步语句块的实现使用的是`monitorenter`和`monitorexit`指令。当执行`monitorenter`指令时，当前线程会尝试获取锁对象对应的monitor的所有权，若monitor的计数器为0，那么线程将成功获取monitor的所有权，并将monitor的计数器记为1。若当前线程已经持有了该monitor，再执行`monitorenter`时，将monitor计数器加1（可重入锁）。若当前monitor已被其他线程占有，则进入阻塞状态，直到该monitor的计数器变为0，再尝试重新获取monitor的所有权。

执行`monitorexit`的线程必须是该monitor的所有者，执行后将monitor的计数器减1，若减1后计数器变为0，该线程则退出该monitor，放弃所有权，其他阻塞的线程开始尝试获取所有权。



### 3.1 无锁

