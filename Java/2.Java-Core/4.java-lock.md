# Java锁

### 1 乐观锁与悲观锁

乐观锁与悲观锁只是广义上的锁的概念，并非具体的锁的实现。二者概念上的区别在于对待操作同步资源时对于竞争的态度。

悲观锁认为当前线程在修改某个数据时，一定会有别的线程也来修改这个数据，所以会给修改的过程枷锁，保证别的线程无法同时修改该数据。

![image-20210728233841772](assets/image-20210728233841772.png)

而乐观锁认为当前线程在修改数据时，不太可能有别的线程过来同时修改，所以我不打算加锁，我只是在更新该数据前，判断数据是否发生了变化，若没有变，说明当前只有我在操作，就把数据更新掉，否则的话说明数据被别的线程修改了，再决定报错或是重来一遍。（下图虚线框中的操作需要保证原子）

![image-20210728233852182](assets/image-20210728233852182.png)

悲观锁在Java中的应用有`sychronized`和`ReentrantLock`，乐观锁的应用有`AtomicInteger`等原子类（`java.util.concurrent.atomic`包）。`AtomicInteger`主要是使用了**CAS**技术来实现原子新增的。

CAS全称 Compare And Swap（比较与交换），是一种无锁算法。旨在不加锁的情况下（无阻塞）来实现多线程间的变量同步。CAS算法涉及三个变量：

- 需要进行读写的变量V
- 进行比较的值A
- 打算写入的值B

*当且仅当V的值等于A时，才允许用B来更新V的值。*这个比较+更新是一个**原子操作**，一般借助CPU指令完成。若比较时不相等，一般会采取重试操作。

 `AtomicInteger`的自增函数`incrementAndGet()`中，使用的是`unsafe.getAndAddInt()`（`Unsafe`类是类似于C语言一样操作内存空间，其只是在JDK的某些地方用的，官方并不推荐开发者直接使用）。

```java
// ----------AtomicInteger----------
public final int incrementAndGet() {
    return unsafe.getAndAddInt(this, valueOffset, 1) + 1;
}

// ----------Unsafe.class(反编译)----------
public final int getAndAddInt(Object var1, long var2, int var4) {
    int var5;
    do {
        var5 = this.getIntVolatile(var1, var2);
    } while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4));

    return var5;
}
```

其先获取想要操作的内存地址上的值，`compareAndSwapInt()`借助底层的原子操作，比较内存地址上的值与预期的值是否相等，若相等则将该内存地址上的值替换为该值加1，并返回原来的值。若不相等，则重新获取该内存地址上的值，再`compareAndSwapInt`()，如此循环，直至替换成功。

