# Java锁

### 1 乐观锁与悲观锁

乐观锁与悲观锁只是广义上的锁的概念，并非具体的锁的实现。二者概念上的区别在于对待操作同步资源时对于竞争的态度。

悲观锁认为当前线程在修改某个数据时，一定会有别的线程也来修改这个数据，所以会给修改的过程枷锁，保证别的线程无法同时修改该数据。

![image-20210728233841772](assets/image-20210728233841772.png)

而乐观锁认为当前线程在修改数据时，不太可能有别的线程过来同时修改，所以我不打算加锁，我只是在更新该数据前，判断数据是否发生了变化，若没有变，说明当前只有我在操作，就把数据更新掉，否则的话说明数据被别的线程修改了，再决定报错或是重来一遍。（下图虚线框中的操作需要保证原子）

![image-20210728233852182](assets/image-20210728233852182.png)

悲观锁在Java中的应用有`sychronized`和`ReentrantLock`，乐观锁的应用有`AtomicInteger`等原子类。`AtomicInteger`主要是使用了**CAS**技术来实现原子新增的。

CAS全称 Compare And Swap（比较与交换），是一种无锁算法。旨在不加锁的情况下（无阻塞）来实现多线程间的变量同步。CAS算法涉及三个变量：

- 需要进行读写的变量V
- 进行比较的值A
- 打算写入的值B

*当且仅当V的值等于A时，才允许用B来更新V的值。*这个比较+更新是一个**原子操作**，一般由系统内核提供。若比较时不相等，一般采取重试操作。



