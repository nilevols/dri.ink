# Java线程池

创建和销毁线程的成本是非常高的，频繁地创建和销毁线程会对应用造成很大的负担，无限制地创建线程更有可能造成应用的崩溃。为了解决这俩问题：1. 创建和销毁线程的开销；2. 管理线程的数量。JDK提供了线程池技术。

## 1 ThreadPoolExecutor类

`java.util.concurrent.ThreadPoolExecutor`类是线程池技术的核心类，其主要参数有：

- `corePoolSize` - 核心线程数量
- `maximumPoolSize` - 最大线程数量
- `keepAliveTime` - 线程存活保持时间
- `unit` - `keepAliveTime` 的单位
- `workQueue` - 任务队列（缓冲队列）
- `threadFactory` - 线程工厂
- `handler` - `RejectedExecutionHandler`，拒绝策略

### 1.1 `corePoolSize` - 核心线程数量

当你向线程池提交一个任务，如果当前线程池中的线程数量小于`corePoolSize`，那么即使此时线程池中有空闲线程，线程池也会帮你创建一个线程。当然还有一种情况是调用了`prestartAllCoreThreads()`或者`prestartCoreThread()`方法，顾名思义，线程池会与先帮你创建`corePoolSize`个线程或一个线程。

### 1.2 `maximumPoolSize` - 最大线程数量

表示在线程池中能创建多少个线程。当你向线程池提交一个任务，如果当前线程池中的线程数量大于等于`corePoolSize`，且小于等于`maximumPoolSize`，且没有空闲线程时，线程池才会新创建线程。若线程池中的线程数量已达到`maximumPoolSize`的话，且当前没有空闲线程时，新提交的任务会被放置在缓冲队列（`workQueue`）中。

### 1.3 `keepAliveTime`与`unit`  - 线程存活保持时间及单位

当线程池中线程的数量大于`corePoolSize`时，若某个空闲线程的空闲时间超过 `keepAliveTime`的话，线程池会尝试shutdown它（调用其`interrupt()`方法）。

在默认情况下，线程池只会shutdown超出核心线程数量的空闲线程，对于核心线程数量内的线程，即使是空闲的也不会管它。

但线程池提供了一个 `allowCoreThreadTimeOut(boolean value)`方法，当`allowCoreThreadTimeOut(true)`时且 `keepAliveTime`大于0的话，线程池也会关闭核心线程数量内的超时空闲线程。

### 1.4 `workQueue` - 任务队列

一个阻塞队列，用于缓存等待执行的任务。

### 1.5 `threadFactory` - 线程工厂

用于创建新线程。默认的线程工厂`java.util.concurrent.Executors.DefaultThreadFactory`采用的是`new Thread()`的方式创建线程，线程的名称格式是"pool-线程池序号-thread-线程序号"。

### 1.6 `handler` - `RejectedExecutionHandler`拒绝策略

当线程池线程数量已满，且任务队列已满的情况下，新提交的任务会走设置的拒绝策略。存在四种拒绝策略：

- `ThreadPoolExecutor.AbortPolicy` - 直接丢弃新提交的任务，并抛出`RejectedExecutionException`异常。**该策略是默认的拒绝策略**
- `ThreadPoolExecutor.CallerRunsPolicy` - 将新提交的任务交由于提交任务的线程（调用`.execute()`的线程）来执行，站在该线程的角度来看，新提交的任务被同步执行了。若线程池已被shutdown，该任务会被丢弃
- `ThreadPoolExecutor.DiscardOldestPolicy` - 丢弃等待任务队列中最早的任务，并尝试重新提交该新任务。若线程池已被shutdown，该任务会被丢弃
- `ThreadPoolExecutor.DiscardPolicy` - 直接丢弃新提交的任务，不抛出任何异常（悄悄地丢弃）

## 2 线程池的种类

JDK推荐使用`java.util.concurrent.Executors`工厂类来创建线程池。常用的几种线程池有：

### 2.1 newFixedThreadPool

`Executors.newFixedThreadPool()`会创建一个指定线程数量的线程池，池中线程的存活保持时间被设置为永久。若线程池满了，新提交的任务会被放入缓冲队列（`LinkedBlockingQueue`）。若期间某线程因执行任务失败而终止，线程会创建新的线程来执行后续的任务。

### 2.2 newCachedThreadPool

`Executors.newCachedThreadPool()`创建的线程池，在其被提交任务时，若有空闲线程就复用，若无空闲线程就新建，不用关心拒绝策略（几乎不会触发拒绝策略， `maximumPoolSize`设的是`Integer.MAX_VALUE`）。**它适合执行大量短执行时间的任务**。

> These pools will typically improve the performance of programs that execute many short-lived asynchronous tasks. 
>
> 对于需要执行大量短存活时间的异步任务的应用程序来说，这种线程池通常会提高其性能。

### 2.3 newSingleThreadExecutor

`Executors.newSingleThreadExecutor()`会创建一个只有一个线程的线程池。非空闲时，新提交的任务会放入阻塞队列（`LinkedBlockingQueue`）。这个线程若是挂掉了，线程池会立刻重新创建线程以执行后续任务。这种线程池**适用于需要保证任务执行顺序的场景**，其同一个时间只有一个任务在执行。

这个工厂方法创建的线程池，使用了`FinalizableDelegatedExecutorService`包装类来保证线程池的配置不会被修改（比如增加线程数量）。

### 2.4 ScheduledThreadPoolExecutor

`Executors.ScheduledThreadPoolExecutor()`创建一个固定线程数量的的线程池，池中线程的存活保持时间被设置为永久。**该线程池支持定时及周期性地执行任务**。若线程池满了，新提交的任务会被放入`DelayedWorkQueue`队列。

### 2.5 几个线程池的对比

| 线程池                      | 核心线程数 | 最大线程数        | 非核心线程空闲存活时间 | 缓冲队列            |
| --------------------------- | ---------- | ----------------- | ---------------------- | ------------------- |
| newFixedThreadPool          | n          | n                 | -                      | LinkedBlockingQueue |
| newCachedThreadPool         | 0          | Integer.MAX_VALUE | 60s                    | SynchronousQueue    |
| newSingleThreadExecutor     | 1          | 1                 | -                      | LinkedBlockingQueue |
| ScheduledThreadPoolExecutor | n          | Integer.MAX_VALUE | 永久                   | DelayedWorkQueue    |

## 3 线程池执行任务的流程

![image-20210723232653907](C:\Users\壮壮家\AppData\Roaming\Typora\typora-user-images\image-20210723232653907.png)

