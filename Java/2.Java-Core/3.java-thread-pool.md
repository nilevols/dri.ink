# Java线程池

创建和销毁线程的成本是非常高的，频繁地创建和销毁线程会对应用造成很大的负担，无限制地创建线程更有可能造成应用的崩溃。为了解决这俩问题：1. 创建和销毁线程的开销；2. 管理线程的数量。JDK提供了线程池技术。

## 1 ThreadPoolExecutor类

`java.util.concurrent.ThreadPoolExecutor`类是线程池技术的核心类，其主要参数有：

- `corePoolSize` - 核心线程数量
- `maximumPoolSize` - 最大线程数量
- `keepAliveTime` - 线程存活保持时间
- `unit` - `keepAliveTime` 的单位
- `workQueue` - 任务队列
- `threadFactory` - 线程工厂
- `handler` - `RejectedExecutionHandler`，拒绝策略

### 1.1 `corePoolSize` - 核心线程数量

当你向线程池提交一个任务，如果当前线程池中的线程数量小于`corePoolSize`，那么即使此时线程池中有空闲线程，线程池也会帮你创建一个线程。当然还有一种情况是调用了`prestartAllCoreThreads()`或者`prestartCoreThread()`方法，顾名思义，线程池会与先帮你创建`corePoolSize`个线程或一个线程。

### 1.2 `maximumPoolSize` - 最大线程数量

表示在线程池中能创建多少个线程。当你向线程池提交一个任务，如果当前线程池中的线程数量大于等于`corePoolSize`，且小于等于`maximumPoolSize`，且没有空闲线程时，线程池才会新创建线程。若线程池中的线程数量已达到`maximumPoolSize`的话，且当前没有空闲线程时，新提交的任务会被放置在缓存队列（`workQueue`）中。

### 1.3 `keepAliveTime`与`unit`  - 线程存活保持时间及单位

当线程池中线程的数量大于`corePoolSize`时，若某个空闲线程的空闲时间超过 `keepAliveTime`的话，线程池会尝试shutdown它（调用其`interrupt()`方法）。

在默认情况下，线程池只会shutdown超出核心线程数量的空闲线程，对于核心线程数量内的线程，即使是空闲的也不会管它。

但线程池提供了一个 `allowCoreThreadTimeOut(boolean value)`方法，当`allowCoreThreadTimeOut(true)`时且 `keepAliveTime`大于0的话，线程池也会关闭核心线程数量内的超时空闲线程。

### 1.4 `workQueue` - 任务队列

一个阻塞队列，用于缓存等待执行的任务。

### 1.5 `threadFactory` - 线程工厂

用于创建新线程。默认的线程工厂`java.util.concurrent.Executors.DefaultThreadFactory`采用的是`new Thread()`的方式创建线程，线程的名称格式是"pool-线程池序号-thread-线程序号"。

### 1.6 `handler` - `RejectedExecutionHandler`拒绝策略

当线程池线程数量已满，且任务队列已满的情况下，新提交的任务会走设置的拒绝策略。存在四种拒绝策略：

- `ThreadPoolExecutor.AbortPolicy` - 直接丢弃新提交的任务，并抛出`RejectedExecutionException`异常。**该策略是默认的拒绝策略**
- `ThreadPoolExecutor.CallerRunsPolicy` - 将新提交的任务交由于提交任务的线程（调用`.execute()`的线程）来执行，站在该线程的角度来看，新提交的任务被同步执行了。若线程池已被shutdown，该任务会被丢弃
- `ThreadPoolExecutor.DiscardOldestPolicy` - 丢弃等待任务队列中最早的任务，并尝试重新提交该新任务。若线程池已被shutdown，该任务会被丢弃
- `ThreadPoolExecutor.DiscardPolicy` - 直接丢弃新提交的任务，不抛出任何异常（悄悄地丢弃）