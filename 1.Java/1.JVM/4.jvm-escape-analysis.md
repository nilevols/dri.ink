# JVM逃逸分析

参考：[Don't Let Your Java Objects Escape](https://dzone.com/articles/do-not-let-your-java-objects-escape)

参考：[详解JVM逃逸分析](http://www.jetchen.cn/EscapeAnalysis/)

参考：[Seeing Escape Analysis Working](https://www.javaadvent.com/2020/12/seeing-escape-analysis-working.html)

今天被问到一个问题，我下意识回答了“是”，回答错误，又发现了一块知识盲区。

> 创建出来的对象都存放在堆中吗？

JVM提供了一个可选的优化方案：逃逸分析（Escape Analysis），它通过分析程序允许JVM将特定的对象直接创建在**线程栈**中，而非堆中。这样做有什么好处呢？如果对象被分配在堆中，那么它的回收只能依赖GC。但如果该对象并不是一个共享对象，不需要对其他线程可见，甚至只是在某个方法中使用，那么该对象没必要分配在堆中，就能免去了GC（回收该对象）的开销，的，可以将其分配在栈空间中，让其随着线程栈（或栈帧）的销毁而销毁。

## 1 什么是逃逸（Escape）

理想情况下，当前线程所创建的对象，只在当前线程中使用，它将随着线程的生命周期的结束而销毁。**如果当前线程创建的对象，暴露到了当前线程之外，能够被其他线程引用，那么就称之为发生了“逃逸”。**

有三种状态来描述一个对象的“逃逸”：

- 全局逃逸（***GlobalEscape***）：一个对象的作用域超出了当前方法或当前线程。比如作为方法的return的内容，比如作为一个对象的静态属性或是某个“全局逃逸”对象的属性，都是“全局逃逸”状态的。甚至，如果某个类的`finalize()`方法被重写了，那么该类型的对象都是“全局逃逸”状态，因为这种对象对于JVM的finalizer来说是可见的。
- 参数逃逸（***ArgEscape***）：对象作为参数被传递给一个方法。但是作用域只能是该方法或该线程。
- 未逃逸（***NoEscape***）：一个对象的作用域只在当前方法或当前线程中。

全局逃逸和参数逃逸的对象必须分配在堆中，因为他们可能存在跨线程访问。未逃逸的对象却可以分配在线程栈中，甚至在某些场景下，它们都没必要被创建为对象，它们被拆解为各自的属性字段只存于栈中。

## 2 逃逸分析（Escape Analysis）做了什么优化

自Java8开始，逃逸分析是默认开启的，在之前的版本需要手动开启，相关参数有：

- `-XX:+DoEscapeAnalysis`：开启逃逸分析
- `-XX:-DoEscapeAnalysis`：关闭逃逸分析
- `-XX:+PrintEscapeAnalysis`：打印逃逸分析日志

### 2.1 锁消除

当对象的作用域只是单个线程内的话（参数逃逸与未逃逸），加锁操作就显得多余了，逃逸分析对多余的加锁操作做了消除处理。

- `-XX:+EliminateLocks`：开启锁消除
- `-XX:-EliminateLocks`：关闭锁消除

### 2.2 标量替换

先要弄清楚标量（scalar）与聚合量（aggregates）的区别。标量是指单纯的数值，比如int等基础类型，它是无法被继续拆解的。聚合量一般指的就是对象，它是由多个标量或是对象组成，可被最终拆解为一堆标量。

如果一个对象未发生逃逸，那就意味着它不会被跨线程访问，那么也就没必要在堆中为其分配空间（作为替代，分配在栈中），减轻一些GC的负担。甚至进一步，都不用“构建”这个对象，只需要将它的成员变量作为“局部变量”存放在栈帧中（拆解为标量）即可。这个（优化）步骤叫做标量替换。

- `-XX:+EliminateAllocations`：开启标量替换
- `-XX:-EliminateAllocations`：关闭标量替换
- `-XX:+PrintEliminateAllocations`：打印标量替换日志

## 3 其他

逃逸分析发生在JIT（just-in-time即时编译）阶段。总的来讲，逃逸分析作为JIT编译器的一个优化手段，主要行为是分析一个新建的对象的作用域以及决定是将它分配在堆上，还是只是将它拆解为成员变量直接用于计算（标量替换）。同时也能做到将未发生全局逃逸的对象的锁给消除掉。
