# JVM逃逸分析

参考：[Don't Let Your Java Objects Escape](https://dzone.com/articles/do-not-let-your-java-objects-escape)

参考：[详解JVM逃逸分析](http://www.jetchen.cn/EscapeAnalysis/)

今天被问到一个问题，我下意识回答了“是”，回答错误，又发现了一块知识盲区。

> 创建出来的对象都存放在堆中吗？

JVM提供了一个可选的优化方案：逃逸分析（Escape Analysis），它通过分析程序允许JVM将特定的对象直接创建在**线程栈**中，而非堆中。这样做有什么好处呢？如果对象被分配在堆中，那么它的回收只能依赖GC。但如果该对象并不是一个共享对象，不需要对其他线程可见，甚至只是在某个方法中使用，那么该对象没必要分配在堆中，就能免去了GC（回收该对象）的开销，取而代之的，可以将其分配在栈空间中，让其随着线程栈（或栈帧）的销毁而销毁。

## 1 什么是逃逸（Escape）

理想情况下，当前线程所创建的对象，只在当前线程中使用，它将随着线程的生命周期的结束而销毁。**如果当前线程创建的对象，暴露到了当前线程之外，能够被其他线程引用，那么就称之为发生了“逃逸”。**

有三种状态来描述一个对象的“逃逸”：

- 全局逃逸（***GlobalEscape***）：一个对象的作用域超出了当前方法或当前线程。比如作为方法的return的内容，比如作为一个对象的静态属性或是某个“全局逃逸”对象的属性，都是“全局逃逸”状态的。甚至，如果某个类的`finalize()`方法被重写了，那么该类型的对象都是“全局逃逸”状态，因为这种对象对于JVM的finalizer来说是可见的。
- 参数逃逸（***ArgEscape***）：对象作为参数被传递给一个方法。但是作用域只能是该方法或该线程。
- 未逃逸（***NoEscape***）：一个对象的作用域只在当前方法或当前线程中。

全局逃逸和参数逃逸的对象必须分配在堆中
