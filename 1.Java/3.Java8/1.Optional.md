# Java8特性之——Optional

在我们日常搬砖的过程中，为了避免NPE，常常需要做各种各样的判空操作：

```java
// Example. 获取员工的部门的名称
employee.getDept().getName(); // 可能会NPE
// ---------------------------------------
if (employee != null) {
    Department dept = employee.getDept();
    if (dept != null) {
        String deptName = dept.getName();
    }
}
```

以上这种写法出现多了，非常影响代码的美观，令人不适。。。Optional的出现就是为了优化判空的写法。

**`java.util.Optional`本质上是一个对象容器，它基于对象的空与非空，提供了一系列的核心方法，用于基于空值判断的代码逻辑。**

## 1 Optional的结构

```java
public final class Optional<T> {
    // 1. 空值常量
    private static final Optional<?> EMPTY = new Optional<>();
    // 2. 被包含的对象
    private final T value;
    // 3. 私有构造函数，只允许通过静态方法创建Optional
    private Optional() {
        this.value = null;
    }
    private Optional(T value) {
        this.value = Objects.requireNonNull(value);
    }
    // ...
}
```

1. 常量`EMPTY`是一个value为空的Option对象。
2. `value`成员变量就是被包含（校验）的目标对象。
3. 两个构造函数都是私有的，只能通过`of`与`ofNullable`这俩静态方法创建Optional对象。

## 2 核心用法 - 构建（of与ofNullable）

```java
// 从非空入参构建Optional
public static <T> Optional<T> of(T value) {
    // 此构造方法若value为空直接抛出NullPointerException
    return new Optional<>(value);
}

// 构建Optional，允许入参为空
public static <T> Optional<T> ofNullable(T value) {
    // value为空则返回空值常量，否则构造目标Optional对象返回
    return value == null ? empty() : of(value);
}

// 返回空值常量
public static<T> Optional<T> empty() {
    @SuppressWarnings("unchecked")
    Optional<T> t = (Optional<T>) EMPTY;
    return t;
}
```

这俩方法都是通过指定的对象构建Optional对象，区别是：

1. `of`方法的入参必须是非空的，若入参为空会直接抛出`NullPointerException`。
2. `ofNullable`方法允许为空的入参，空值判断写法里基本都用的这个方法。

## 3 核心用法 - 判空及处理（orElse与orElseGet与orElseThrow）

